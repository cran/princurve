---
title: "Explanation of the principal curve algorithm"
author: "Robrecht Cannoodt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Explanation of the principal curve algorithm}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<!-- github markdown using
rmarkdown::render("vignettes/algorithm.Rmd", output_format = "github_document")
-->

```{r setup, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(comment = "#>", collapse = TRUE, echo = FALSE)
set.seed(1)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(princurve)
```

The workings of calculating a principal curve is explained
with an example. Calculating the principal curves is an interative process.

```{r iterative, fig.show='animate', ffmpeg.format='gif'}
set.seed(1)
z <- sort(runif(100, -1.4 * pi, .4 * pi))
s <- data_frame(
  x = cos(z) * 1.5,
  y = sin(z)
)
x <- s %>% 
  sample_frac(1) %>% 
  mutate(
    x = x + rnorm(length(x), 0, .05),
    y = y + rnorm(length(x), 0, .05)
  )

for (it in seq(0, 10)) {
  fit <- principal_curve(as.matrix(x), maxit = it)
  g <- ggplot() +
    geom_point(aes(x, y), x, colour = "darkgray") +
    geom_path(aes(x, y), as_data_frame(fit$s[fit$ord, ])) +
    theme_bw()+
    coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
    labs(title = paste0("Iteration ", it)) 
  print(g)
}
```

## Pseudocode
```r
s = principal_component(x)
x_proj = project(x, s)
lambda = arc_length(x_proj)

for (it = 1..max_iter) {
  s = smooth(lambda, x)
  s = approximate(s)
  x_proj = project(x, s)
  lambda = arc_length(x_proj)
}
```

## Initialisation
The principal curve `s` is initialised (at iteration 0) by
calculating the principal component. All points in `x` are projected
orthogonally onto `s`, and the arc-length `lambda` of each projection w.r.t.
to the start of the curve is calculated.

```{r initialisation, fig.show='animate', ffmpeg.format='gif'}
fit0 <- principal_curve(as.matrix(x), maxit = 0)

ggplot() +
  geom_point(aes(x, y), x) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(title = "Step 0a: Initialise curve with principal component\nStep 0b: Orthogonally project points to curve\nStep 0c: Calculate arc-length of projections w.r.t. the origin of the curve")

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit0$s[fit0$ord, ])) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(title = "> Step 0a: Initialise curve with principal component\nStep 0b: Orthogonally project points to curve\nStep 0c: Calculate arc-length of projections w.r.t. the origin of the curve")

ggplot() +
  geom_segment(aes(x = x$x, xend = fit0$s[,1], y = x$y, yend = fit0$s[,2]), linetype = "dashed") +
  geom_path(aes(x, y), as_data_frame(fit0$s[fit0$ord, ]), colour = "darkgray") +
  geom_point(aes(x, y), x, colour = "darkgray") +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Step 0a: Initialise curve with principal component\n> Step 0b: Orthogonally project points to curve\nStep 0c: Calculate arc-length of projections w.r.t. the origin of the curve")

ggplot() +
  geom_segment(aes(x = x$x, xend = fit0$s[,1], y = x$y, yend = fit0$s[,2]), linetype = "dashed", colour = "lightgray") +
  geom_path(aes(x, y), as_data_frame(fit0$s[fit0$ord, ]), colour = "darkgray") +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_point(aes(x, y), as_data_frame(fit0$s)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Step 0a: Initialise curve with principal component\nStep 0b: Orthogonally project points to curve\n> Step 0c: Calculate arc-length of projections w.r.t. the origin of the curve")
```

## Iteration 1
Each iteration consists of three steps: smoothing, approximation, and projection.

### Smoothing: calculate new curve
During the smoothing step, a new curve is computed by smoothing each 
dimension in `x` w.r.t. the arc-length `lambda` calculated for the previous curve.

```{r smooth, fig.show='animate', ffmpeg.format='gif'}
fit1 <- principal_curve(as.matrix(x), maxit = 1)

xdf <- x %>% 
  mutate(lambda = fit0$lambda) %>%
  arrange(lambda) %>% 
  gather(dimension, value, -lambda) %>% 
  group_by(dimension) %>% 
  mutate(smooth = smooth.spline(lambda + runif(length(lambda), 0, .001), value, df = 5)$y) %>% 
  ungroup()

ggplot(xdf) +
  geom_point(aes(lambda, value)) +
  geom_line(aes(lambda, smooth)) +
  facet_wrap(~dimension, scales = "free") +
  theme_bw()
```

```{r beforeafter, fig.show='animate', ffmpeg.format='gif'}
ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit0$s[fit0$ord, ])) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Before")

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit1$s[fit1$ord, ])) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "After")
```

### Approximation: simplify curve
In the next step (projection), each of the `n` points in `x` will get compared to each segment in the curve `s`. 
After the smoothing step, the curve consists of `n` points. Thus, the projection step would have a complexity
of $O(n^2)$. In order to make this step $O(n)$, the `approx_points = 100` parameter can be used to 
first approximate by a curve with 100 points.

```{r approx, fig.show='animate', ffmpeg.format='gif'}
xout <- seq(min(xdf$lambda), max(xdf$lambda), length.out = 100)
xadf <- xdf %>% 
  group_by(dimension) %>% 
  do({
    data_frame(lambda = xout, dimension = .$dimension[[1]], smooth = stats::approx(.$lambda, .$smooth, xout)$y)
  }) %>% 
  ungroup() %>% 
  spread(dimension, smooth)

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit1$s[fit1$ord, ])) +
  geom_point(aes(x, y), as_data_frame(fit1$s)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Before")

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), xadf) +
  geom_point(aes(x, y), xadf) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "After")
```

### Projection: calculate new lambda
The projection step is same as before; all the points are orthogonally 
projected onto the new curve, and the arc-length `lambda` is recalculated 
for the new projections.

```{r relambda}
ggplot() +
  geom_segment(aes(x = x$x, xend = fit1$s[,1], y = x$y, yend = fit1$s[,2]), linetype = "dashed", colour = "lightgray") +
  geom_path(aes(x, y), as_data_frame(fit1$s[fit1$ord, ]), colour = "darkgray") +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_point(aes(x, y), as_data_frame(fit1$s)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y")
```

This process is repeated until convergence or until a predefined number of iterations has passed.

## Iteration 2
For clarity's sake, the smoothing and projection steps are also shown for iteration 2.

### Smoothing: calculate new curve
During the smoothing step, a new curve is computed by smoothing each 
dimension in `x` w.r.t. the arc-length `lambda` calculated for the previous curve.

```{r smooth2, fig.show='animate', ffmpeg.format='gif'}
fit2 <- principal_curve(as.matrix(x), maxit = 2)

xdf2 <- x %>% 
  mutate(lambda = fit1$lambda) %>%
  arrange(lambda) %>% 
  gather(dimension, value, -lambda) %>% 
  group_by(dimension) %>% 
  mutate(smooth = smooth.spline(lambda + runif(length(lambda), 0, .001), value, df = 5)$y) %>% 
  ungroup()

ggplot(xdf2) +
  geom_point(aes(lambda, value)) +
  geom_line(aes(lambda, smooth)) +
  facet_wrap(~dimension, scales = "free") +
  theme_bw()
```

```{r beforeafter2, fig.show='animate', ffmpeg.format='gif'}
ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit1$s[fit1$ord, ])) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Before")

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit2$s[fit2$ord, ])) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "After")
```

### Approximation: simplify curve
The curve is simplified in order to make the projection step easier.

```{r approx2, fig.show='animate', ffmpeg.format='gif'}
xout2 <- seq(min(xdf2$lambda), max(xdf2$lambda), length.out = 100)
xadf2 <- xdf2 %>% 
  group_by(dimension) %>% 
  do({
    data_frame(lambda = xout2, dimension = .$dimension[[1]], smooth = stats::approx(.$lambda, .$smooth, xout2)$y)
  }) %>% 
  ungroup() %>% 
  spread(dimension, smooth)

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), as_data_frame(fit2$s[fit2$ord, ])) +
  geom_point(aes(x, y), as_data_frame(fit2$s)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "Before")

ggplot() +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_path(aes(x, y), xadf2) +
  geom_point(aes(x, y), xadf2) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y", title = "After")
```

### Projection: calculate new lambda
All the points are orthogonally 
projected onto the new curve, and the arc-length `lambda` is recalculated 
for the new projections.

```{r relambda2}
ggplot() +
  geom_segment(aes(x = x$x, xend = fit2$s[,1], y = x$y, yend = fit2$s[,2]), linetype = "dashed", colour = "lightgray") +
  geom_path(aes(x, y), as_data_frame(fit2$s[fit2$ord, ]), colour = "darkgray") +
  geom_point(aes(x, y), x, colour = "darkgray") +
  geom_point(aes(x, y), as_data_frame(fit2$s)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1.6, 1.6), ylim = c(-1.1, 1.1)) +
  labs(x = "x", y = "y")
```
